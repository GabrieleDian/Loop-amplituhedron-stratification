restart
M2

-- In this code we compute the inclusion relations between boundary strata

-- The code is organized as follows:
    -- Definition of utility functions
    -- Gr(2,4)x Gr(2,4) coordinate ring 
    -- Load result boundaries
    -- Compute inclusing relations


--------------------------------
-- Definition of utility functions
--------------------------------

--Input:flattenAll({{1},2,{{{3}}}}) OutPut : {1,2,3}
flattenAll = L -> (
    if class L === List then
        flatten apply(L, flattenAll)
    else
        L
)


-- mySub act as sub, but threads over List . 
-- Test 1: mySub(p12,Cyclic )== sub(p12,Cyclic ); 
-- Test 2: mySub({p12,q23}, Cyclic)=={p23,q34}
mySub = (x,transfromation) -> if class x === List then apply(x, i-> mySub(i,transfromation)) else  sub(x,transfromation)



-- nestSub(x0, transf, n) generates a list starting with x0, applying mySub(..,transf) n-1 times. x0 cab be a variable, ideal or a nested  lists
-- Example: nestSub(ideal p12, {p12=>p23,p23=>- p13}, 2) Output:  {ideal p12, ideal p23, ideal(-p13)};

nestSub = (x0, transf, n) -> ( L:= x0;  temp = for i from 1 to n list ( L =  mySub( L, transf)); prepend (x0,temp) )

testCodim = (i, j)-> ( codim(i)==j)  -- Returns true if codim(i)==j


--AllIntersections (list1,list2) gives all the irreducible components of all possible intersections of ideals in list1 and ideals in list 2
AllIntersections = ( list1,list2)-> (for i from 0 to length(list1)-1 list(
            for j from 0 to length(list2)-1 list(
                print(i,j);
                J= decompose (list1_i + list2_j) 
            )
        ))

--Input AllPairs({1},{a,b}) Out: {{1, a}, {1, b}}
AllPairs = ( list1,list2)-> flatten (for i from 0 to length(list1)-1 list(
            for j from 0 to length(list2)-1 list(
                {list1_i,list2_j}
            )
        ))

--------------------------------
--Gr(2,4)x Gr(2,4) coordinate ring
--------------------------------

-- We start by setting up the coordinate ring of the Gr(2,4) x Gr(2,4). 

p = nextPrime 1000; 
plRing = ZZ/p[p13,p14,p23,p24,p34,q13,q14,q23,q24,q34,q12,p12] -- Polynomial ring of all Pluckers

PluckerP = ideal(p12*p34-p13*p24+p23*p14); -- Plucker coordinates of the line AB
PluckerQ = ideal(q12*q34-q13*q24+q23*q14); -- Plucker coordinates of the line CD

Rq=plRing/ (PluckerP+PluckerQ); --  Gr(2,4) x Gr(2,4) Quotient ring

-- Then we can define the mutal positivity <ABCD> as
D = p12*q34-p13*q24+p14*q23+p23*q14-p24*q13+p34*q12;
-- The ideal correspondent to the algebraic boundary is instead given by 
I = ideal( p12*p23*p34*p14 * q12*q23*q34*q14 * D);

--------------------------------
-- D_4 x Z^2 symmetry 
--------------------------------

-- Next we define the generator of the symmetry group on the Amplituhedron 

Cyclic = {p12=>p23, p23=>p34, p34=>-p14, p14=>-p12, p13=>p24, p24=>-p13, q12=>q23, q23=>q34, q34=>-q14, q14=>-q12, q13=>q24, q24=>-q13};
Mirror = {p12=>q12, p23=>q23, p34=>q34, p14=>q14, p13=>q13, p24=>q24, q12=>p12, q23=>p23, q34=>p34, q14=>p14, q13=>p13, q24=>p24};
Parity = {p12=>-p12,p23=>p14, p34=>-p34, p14=>p23, p13=>p24, p24=>p13,q12=>-q12, q23=>q14, q34=>-q34, q14=>q23, q13=>q24, q24=>q13};


-- Then we generate the full symmetry group  

-- allSym(i) gives a list containing  all the ideals connected to i by a cyclic or p<->q symmetry
-- Example length allSym(ideal (p12))  Output:  16
allSym = x-> ( 
    allIdeals:=flattenAll( nestSub(nestSub(nestSub(x, Cyclic, 3),Mirror,1), Parity,1));
    parallelApply(allIdeals,i-> trim ideal groebnerBasis trim i)
)

-- We will be interseted in looking at representatives of ideals under the symmetry group.
-- We implement therefore the following function.

-- canonicalizeIdeal(I) gives a representative of the orbit generated by the action of Cyclic and Mirror on I. The sorting between the orbit elements is given by the function sort based on the binary operator >.
--canonicalizeIdeal (ideal q23 ) Output : ideal p12
canonicalizeIdeal = x -> ideal first sort apply(allSym(x), i -> flatten entries gens i)

-----------------------------------
--- EXTRACT RESULT FROM SAVED FILES
-----------------------------------

-- The file stratification_representatives.txt contains nested list where each elements are the representatives
-- of strata at each codimension. This are further subdivided into boundaries and residual.
-- To load the file, first set add to path the directory where the file are located


myPath = "/home/.../"; -- Path example
repData = value get(myPath | "bound_vs_residual.txt"); -- loading


-- We can then assign to the variable boundRepTemp the boundary representatives
boundRepTemp=apply(repData,first);
apply(oo,length) -- {2, 7, 15, 26, 29, 28, 12, 5}

-- Then we need to write element is boundRepTemp as ideals
boundRep = apply(boundRepTemp,i-> apply(i,ideal));

--- Go from the representatives to the full set of boundaries
boundaries =  apply(boundRep, i-> unique flatten apply(i, allSym));


--Check multiplicities of boundary components
apply(boundaries,length)--- {9, 44, 144, 286, 356, 306, 148, 34}

 
-----------------------
-- Poset
-----------------------


-- Inclusion relations can be computed with the function isSubset(I,J), 
-- which gives true if I is contained in J
 isSubset (ideal p12, ideal (p12, q12)) -- true

-- We add the whole space and the emply space to the poset. ideal() is an ideal of ZZ by default, thats why we use promote
posElements = join( {{promote(ideal (),Rq)}},boundaries,{{promote(ideal (1),Rq)}});

-- genRelations give all pairs (i,j) with i in  list 1 and j in list 2 such that i constains j
genRelations = (list1,list2) -> select( AllPairs ( list1,list2 ), i -> isSubset(i_0,i_1) )

-- all rel contains all inclusion relations in the real stratification
allrel = (for i from 0 to 8 list(  genRelations (posElements_i,posElements_(i+1))));

"Real_strat_poset"<<toString allrel<<close;

 length join(toSequence allrel)-- 6951
