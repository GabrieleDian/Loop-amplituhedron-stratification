
M2
restart
---------------------------------------------------------------
-- 2-LOOP AMPLITUHEDRON BOUNDARY STRATIFICATION
---------------------------------------------------------------

-- In this code we are compute for 4-point 2-loop amplituhedron the algebraic stratification 
-- as defined in eq () of 

-- The code is organized as follows:
    -- Definition of utility functions
    -- Gr(2,4)x Gr(2,4) coordinate ring and algebraic boundary
    -- D_4 x Z^2 symmetry 
    -- Functions for strata computation
    -- Algebraic boundary computation
    -- Normality checks for strata


--------------------------------
-- Definition of utility functions
--------------------------------

--Input:flattenAll({{1},2,{{{3}}}}) OutPut : {1,2,3}
flattenAll = L -> (
    if class L === List then
        flatten apply(L, flattenAll)
    else
        L
)


-- mySub act as sub, but threads over List . 
-- Test 1: mySub(p12,Cyclic )== sub(p12,Cyclic ); 
-- Test 2: mySub({p12,q23}, Cyclic)=={p23,q34}
mySub = (x,transfromation) -> if class x === List then apply(x, i-> mySub(i,transfromation)) else  sub(x,transfromation)



-- nestSub(x0, transf, n) generates a list starting with x0, applying mySub(..,transf) n-1 times. x0 cab be a variable, ideal or a nested  lists
-- Example: nestSub(ideal p12, {p12=>p23,p23=>- p13}, 2) Output:  {ideal p12, ideal p23, ideal(-p13)};

nestSub = (x0, transf, n) -> ( L:= x0;  temp = for i from 1 to n list ( L =  mySub( L, transf)); prepend (x0,temp) )

testCodim = (i, j)-> ( codim(i)==j)  -- Returns true if codim(i)==j


--AllIntersections (list1,list2) gives all the irreducible components of all possible intersections of ideals in list1 and ideals in list 2
AllIntersections = ( list1,list2)-> (for i from 0 to length(list1)-1 list(
            for j from 0 to length(list2)-1 list(
                print(i,j);
                J= decompose (list1_i + list2_j) 
            )
        ))

--Input AllPairs({1},{a,b}) Out: {{1, a}, {1, b}}
AllPairs = ( list1,list2)-> flatten (for i from 0 to length(list1)-1 list(
            for j from 0 to length(list2)-1 list(
                {list1_i,list2_j}
            )
        ))


--------------------------------
--Gr(2,4)x Gr(2,4) coordinate ring
--------------------------------

-- We start by setting up the coordinate ring of the Gr(2,4) x Gr(2,4). 

p = nextPrime 1000; 
plRing = ZZ/p[p13,p14,p23,p24,p34,q13,q14,q23,q24,q34,q12,p12] -- Polynomial ring of all Pluckers

PluckerP = ideal(p12*p34-p13*p24+p23*p14); -- Plucker coordinates of the line AB
PluckerQ = ideal(q12*q34-q13*q24+q23*q14); -- Plucker coordinates of the line CD

Rq=plRing/ (PluckerP+PluckerQ); --  Gr(2,4) x Gr(2,4) Quotient ring

-- Then we can define the mutal positivity <ABCD> as
D = p12*q34-p13*q24+p14*q23+p23*q14-p24*q13+p34*q12;
-- The ideal correspondent to the algebraic boundary is instead given by 
I = ideal( p12*p23*p34*p14 * q12*q23*q34*q14 * D);

--------------------------------
-- D_4 x Z^2 symmetry 
--------------------------------

-- Next we define the generator of the symmetry group on the Amplituhedron 

Cyclic = {p12=>p23, p23=>p34, p34=>-p14, p14=>-p12, p13=>p24, p24=>-p13, q12=>q23, q23=>q34, q34=>-q14, q14=>-q12, q13=>q24, q24=>-q13};
Mirror = {p12=>q12, p23=>q23, p34=>q34, p14=>q14, p13=>q13, p24=>q24, q12=>p12, q23=>p23, q34=>p34, q14=>p14, q13=>p13, q24=>p24};
Parity = {p12=>-p12,p23=>p14, p34=>-p34, p14=>p23, p13=>p24, p24=>p13,q12=>-q12, q23=>q14, q34=>-q34, q14=>q23, q13=>q24, q24=>q13};


-- Then we generate the full symmetry group  

-- allSym(i) gives a list containing  all the ideals connected to i by a cyclic or p<->q symmetry
-- Example sub(ideal (p12),Cyclic) Output:  {ideal p34, ideal p14, ideal p12, ideal p23, ideal q34, ideal q14, ideal q12, ideal q23}
allSym = x-> ( 
    allIdeals:=flattenAll( nestSub(nestSub(nestSub(x, Cyclic, 3),Mirror,1), Parity,1));
    parallelApply(allIdeals,i-> trim ideal groebnerBasis trim i)
)

-- We can check that the algebraic boundary I is invarinat under the symmetries
length unique allSym(I) ==1

-- We will be interseted in looking at representatives of ideals under the symmetry group.
-- We implement therefore the following function.

-- canonicalizeIdeal(I) gives a representative of the orbit generated by the action of Cyclic and Mirror on I. The sorting between the orbit elements is given by the function sort based on the binary operator >.
--canonicalizeIdeal (ideal q23 ) Output : ideal p12
canonicalizeIdeal = x -> ideal first sort apply(allSym(x), i -> flatten entries gens i)



--------------
-- Functions for strata computation
---------------

-- We want to remove ideal that correspond to empty varieties in the Grassmannian. We do this with the function removeBadStrata.
-- Alternatively one could define the coordinate ring as projective

-- Input testBadIdeal( ideal(p12)) Output: true
testBadIdeal = I ->  not (isSubset( ideal(q12,q23,q34,q14,q24,q13),I) or isSubset( ideal(p12,p23,p34,p14,p24,p13),I));
-- Input removeBadStrata({ideal p12}) Output: {ideal(p12)}
removeBadStrata = x-> select(x, testBadIdeal );


-- computeNextStrata(representatives, boundaries)
-- This function takes as input:
--   - 'representatives': a list of strata representatives
--   - 'boundaries': a list of all current strata boundaries
-- 
-- It outputs:
--   - The new list of strata representatives
--   - The updated list of strata boundaries, both at one codimension higher.
-- 
-- The function works by:
--   1. Computing the codimension for the next set of strata.
--   2. Finding all intersections between the representatives and remaining boundaries.
--   3. Filtering for elements with the desired codimension.
--   4. Applying symmetry operations to the filtered results and removing invalid strata.
--   5. Returning the canonicalized set of new representatives and boundaries.
computeNextStrata:= ( representatives,boundaries) -> (
    cod:= codim boundaries_1 +1; -- codimension of the next strata
    intersections:= AllIntersections(representatives,(boundaries )); -- Compute all intersections
    interRightCod:= select((unique flattenAll intersections), iii -> testCodim(iii,cod)); -- select elements with the right codimension
    newBoundaries:= removeBadStrata unique flatten apply(interRightCod, allSym); -- Take the cyclic/loop symmetry closure of the result
    newRepresentatives:= removeBadStrata unique apply( newBoundaries, canonicalizeIdeal); -- boudaries modded by symmetry
    (newRepresentatives, newBoundaries)
)


----------------------------------
--  Algebraic boundary computation
----------------------------------


    -----------------
    -- Codimension 1
    -----------------

-- At codimension 1 we just need to compute the irreducible compoenents of I and mod by the symmetries

Boundaries1= decompose( I)
#Boundaries1 -- We have 9 cod-1 boundaries

Representatives1= unique apply(Boundaries1, canonicalizeIdeal) ;
#Representatives1 -- We have 2 cod-1 boundaries mod dihedral/loop symmetries

"Representatives1"<<toString Representatives1<<close;
currentDirectory() 

    -----------------
    -- Codimension 2
    -----------------

(Representatives2,Boundaries2)=computeNextStrata(Representatives1,Boundaries1);
#Representatives2 --  cod-3 representatives are 7
#Boundaries2 --  cod-3 boudaries are 44 

 "Representatives2"<<toString Representatives2<<close; --save result

    -----------------
    -- Codimension 3
    -----------------
(Representatives3,Boundaries3)=computeNextStrata(Representatives2,Boundaries2);
#Representatives3 --  cod-3 representatives are 15
#Boundaries3 --  cod-3 boudaries are 144 

 "Representatives3"<<toString Representatives3<<close; --save result


    -----------------
    -- Codimension 4
    -----------------

(Representatives4,Boundaries4)=computeNextStrata(Representatives3,Boundaries3);
#Representatives4 --  cod-4 representatives are 31
#Boundaries4 --  cod-4 boudaries are 324 


 "Representatives4"<<toString Representatives4<<close; --save result

    -----------------
    -- Codimension 5
    -----------------

(Representatives5,Boundaries5)=computeNextStrata(Representatives4,Boundaries4);

#Representatives5 --  cod-5 representatives are 38
#Boundaries5 --  cod-5 boudaries are 450 

 "Representatives5"<<toString Representatives5<<close; --save result

    -----------------
    -- Codimension 6
    -----------------

(Representatives6,Boundaries6)=computeNextStrata(Representatives5,Boundaries5);

#Representatives6 --  cod-5 representatives are 15
#Boundaries6 --  cod-5 boudaries are 44 

 "Representatives6"<<toString Representatives6<<close; --save result

    -----------------
    -- Codimension 7
    -----------------

(Representatives7,Boundaries7)=computeNextStrata(Representatives6,Boundaries6);

#Representatives7 --  cod-7 representatives are 15
#Boundaries7 --  cod-7 boudaries are 44 

 "Representatives7"<<toString Representatives7<<close; --save result

    -----------------
    -- Codimension 8
    -----------------
(Representatives8,Boundaries8)=computeNextStrata(Representatives7,Boundaries7);

#Representatives8 --  cod-5 representatives are 15
#Boundaries8 --  cod-5 boudaries are 44 

 "Representatives8"<<toString Representatives8<<close; --save result



 ------------------------------
 ---Normality checks for strata
 ------------------------------

 mySingualLocus = x -> (  
    singR := ideal singularLocus (sub(x,plRing)+ sub(PluckerQ,plRing) + sub(PluckerP,plRing)); -- compute singular locus in R
 singRq:= decompose ideal gens gb sub(singR,Rq); -- Map to Rq and compute gb + decomposition
 removeBadStrata(singRq) -- remove empty projective varieties
 )

--test
I1= ideal (p12*(p12*q34-p13*q24+p14*q23+p23*q14-p24*q13+p34*q12))
mySingualLocus I1;
apply(oo,codim) -- {2,4,4}  The first ideal is the intersection of the irr components as expected


-- Let us compute all singularities systematically
-- We can see that all our strata are regular, that is their singular locus has cod-2 or greater

singCod1=flatten apply(Representatives1, mySingualLocus);
apply(oo,codim) -- {4,4}

singCod2= apply(Representatives2, mySingualLocus);
unique apply(flatten singCod2,codim) -- {5}

singCod3= apply(Representatives3, mySingualLocus);
unique apply(flatten oo,codim) -- {6,8}

singCod4= apply(Representatives4, mySingualLocus);
unique apply(flatten oo,codim) -- {7,8}

singCod5= apply(Representatives5, mySingualLocus);
unique apply(flatten oo,codim) -- {8}

singCod6= apply(Representatives6, mySingualLocus);
unique apply(flatten oo,codim) -- {}

singCod7= apply(Representatives7, mySingualLocus);
unique apply(flatten oo,codim) -- {}

singCod8= apply(Representatives8, mySingualLocus);
unique apply(flatten oo,codim) -- {}

